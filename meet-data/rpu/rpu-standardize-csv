#!/usr/bin/env python3
# Given a results.csv as outputted by rpu-parse, parse each sheet one at a time
# and join all the sheets together into an OpenPowerlifting-formatted CSV file.

import sys

sys.path.append('../../scripts')
sys.path.append('scripts')
import oplcsv
import re

def die(s):
    print(s, file=sys.stderr)
    sys.exit(1)


# Given the array of lines, split it up into an array per-sheet.
def split_by_sheet(lines):
    # Skip past the overview.
    assert lines[0][0] == 'Overview'
    for i in range(len(lines)):
        if 'Sheet' in lines[i][0]:
            break
    assert i < len(lines)
    assert 'Sheet' in lines[i][0]

    sheetlist = []
    sheet = None

    for line in lines[i:]:
        # If this line starts a new sheet, generate a new array.
        if 'Sheet' in line[0]:
            sheet = []
            sheetlist.append(sheet)
        sheet.append(line)

    return sheetlist


# Given the name of a sheet, return a dictionary describing the sheet.
def parse_sheetname(s):
    obj = {}

    federation = ''
    event = None
    amateur = 'Pro' # By default, unless otherwise specified.
    tested = '' # By default, unless otherwise specified.
    equipment = 'Wraps' # By default, unless otherwise specified.

    # Parse word-by-word to make sure that every word is understood. 

    if 'без экип' in s.lower(): #Need to do 'without equipment' seperately
        equipment = 'Raw'
        s = s.replace('без экипировк','').replace('без экип','')


    s= s.replace('.',' ').replace('"','').replace('_',' ')

    s=s.lower().replace('д к','дк') #Drug tested

    for word in s.lower().split():
        # Federations
        if word == 'wrpf':
            assert not federation
            federation = 'WRPF'
        elif word == 'спр': # Some other federation that does multi-ply.
            assert not federation
            federation = 'SPR'
        elif word == 'wrpf-pro':
            assert not federation
            federation = 'WRPF'
        elif word == 'gpa':
            assert not federation
            federation = 'GPA'

        # Events
        elif word == 'пл' or word == 'пауэрлифтинг' or word == 'pl' or word == 'пауэрифтинг' or word =='пауэлифтинг':
            assert not event
            event = 'SBD'
        elif word == 'присед' or word == 'sq':
            assert not event
            event = 'S'
        elif word == 'жим' or word == 'bp' or word =='bench' or word == 'жд':
            assert not event or event == 'B'
            event = 'B'
            if equipment == 'Wraps':
                equipment = 'Raw'
        elif word == 'тяга' or word == 'dl':
            assert not event
            event = 'D'
            if equipment == 'Wraps':
                equipment = 'Raw'
        elif word == 'двоеборье' or word == 'pp':
            assert not event
            event = 'BD'
            if equipment == 'Wraps':
                equipment = 'Raw'

        # Equipment
        elif word == 'однослой' or word == 'однослое' or word =='односл' or word == 's ply' or word =='однослойной' or word =='1-ой':
            equipment = 'Single-ply'
        elif word in ['экипировке','m ply','eq','многослой','экипировка']:
            equipment = 'Multi-ply'
        elif word in ['slinghot','sling-shot','soft','СПР','софт','облегченная']:
            equipment = 'Multi-ply'
            event = 'B'
        elif word == 'бинты' or word == 'бинтах' or word == 'wraps':
            equipment = 'Wraps'

        # Booleans.
        elif word == 'люб.' or word == 'любители':
            amateur = 'Amateur'
        elif word == 'pro':
            assert amateur == 'Pro'
        elif word == 'дк' or word == 'д_к' or word =='dr test' or word == 'dt' or word == 'д к ':
            tested = 'Tested'

        # Grammatical ignorables.
        elif word == 'в':
            pass
        elif word == 'лежа':
            pass
        elif word == 'на':
            pass
        elif word == 'и':
            pass
        elif word == 'с':
            pass

        # Other ignorables.
        elif word == 'сфо': # Not sure.
            pass
        elif word == 'становая': # First word in 'deadlift'.
            pass
        elif word == 'raw':
            pass
        elif word == 'экипировки' or word =='экип' : #Equipment
            pass
        elif word == 'bp+dl':
            pass
        elif word == 'handicaped': #We don't seperately track Paralympic bench right now
            pass
        elif word == 'spr' or word == 'ultra' or word =='standart' or word == 'стандарт' or word == 'ультра': #Extra terms for slingshot bench
            pass
        elif word =='фжд': #Don't know what this means
            pass
        elif word == 'любители':#Amateur
            pass
        elif word.strip() =='макс' or word =='максимум': #Maximum
            pass
        elif word =='армейский': #Army
            pass
        elif word.strip() == 'люб':
            pass
        elif word == 'силовое':
            pass
        else:
            die('Fix parse_sheetname(): Unknown word "%s" in "%s"' % (word, s))
    assert event

    obj['federation'] = federation
    obj['event'] = event
    obj['amateur'] = amateur
    obj['tested'] = tested
    obj['equipment'] = equipment

    return obj


# Find the line that contains column information (the line below does also).
def get_header_linenum(sheet):
    for ii in range(len(sheet)):
        if sheet[ii][0] == 'Место' or sheet[ii][0]=='Place':
            return ii
    #Sometimes place is not labelled, if not find name
    for ii in range(len(sheet)):
        if sheet[ii][1] == 'ФИО':
            sheet[ii][0]='Место'
            return ii

    die("get_header_linenum() failed to find the header.")

# Header is two merged rows, recombine these back into one row here
def fix_headers(sheet):
    headernum=get_header_linenum(sheet)
    header = sheet[headernum]

    lineabove = sheet[headernum-1] #Need some error checking here
    linebelow = sheet[headernum+1]

    #Name has split below rest of data
    if header[1] == '' and lineabove[1] != '':
        header = [(lineabove[ii]+" "+header[ii]).strip() for ii in range(0,len(header))]
        sheet[headernum] =['' for x in header]
        headernum=headernum-1
    elif header[1] == '' and linebelow[1] != '':
        header = [(header[ii]+" "+linebelow[ii]).strip() for ii in range(0,len(header))]
        sheet[headernum-1] =['' for x in linebelow]
    else: #Attempt numbers always split below
        header = [(header[ii]+" "+linebelow[ii]).strip() for ii in range(0,len(header))]
        sheet[headernum-1] =['' for x in linebelow]
    sheet[headernum]=header

    return sheet


#Sometimes we get country/city/state instead of just country
def split_country(csv):
    if 'Country/City/State' in csv.fieldnames:
        idx = csv.index('Country/City/State')
        for row in csv.rows:
            parts = row[idx].split('/')

            row[idx] = parts[0]
        csv.fieldnames[idx] = 'Country'





def parse_fieldnames(sheet):
    fieldnames = []

    headernum = get_header_linenum(sheet)
    header = sheet[headernum]
    # Name all the columns.
    iterable = iter(range(len(header)))
    for i in iterable:
        text = header[i].lower()

        if text == 'место' or text == 'place':
            fieldnames.append('Place')
        elif text == 'фио':
            fieldnames.append('InternationalName')
        elif text == 'name':
            fieldnames.append('Name')
        elif 'возра' in text or 'возро' in text: #There are a stupid number of ways to write this column so using this as a catch-all
            fieldnames.append('Division-Age')
        elif text in ['собств. вес','собств.','соб.','вес','собственный вес','собственный','body weight','собcтвенный вес','собст. вес','соб. вес']:
            fieldnames.append('BodyweightKg')
        elif text == 'team':
            fieldnames.append('Team')
        elif text == 'wilks' or text == 'gloss' or text == 'коэф' or text =='resh' or text =='wilks/залуцкий' or text =='willks':
            fieldnames.append('IGNORE') # This is not the Wilks, but the WilksCoefficient.
        elif text == 'команда' or text =='coach': # Coach
            fieldnames.append('IGNORE')
        elif text == 'город/ область' or text== 'город' or text =='город/область':
            fieldnames.append('IGNORE') # We don't care about city-level information.
        elif text == 'сountry/city/state' or text =='страна/город/область':
            fieldnames.append('Country/City/State')
        elif text == 'присед 1' or text == 'squat 1':
            assert header[i+1] == '2'
            assert header[i+2] == '3'
            assert header[i+3].lower().replace('.','') in ['рек','rec']
            fieldnames.append('Squat1Kg')
            fieldnames.append('Squat2Kg')
            fieldnames.append('Squat3Kg')
            fieldnames.append('Squat4Kg')
            [next(iterable) for x in range(3)]

        elif text == 'жим' or text == 'жим 1' or text == 'benchpress 1' or text == 'жим макс кг. 1' or text =='жим на максимум 1' or text =='жим вес':
            assert header[i+1] == '2'
            assert header[i+2] == '3'
            assert header[i+3].lower().replace('.','') in ['рек','rec']
            fieldnames.append('Bench1Kg')
            fieldnames.append('Bench2Kg')
            fieldnames.append('Bench3Kg')
            fieldnames.append('Bench4Kg')
            [next(iterable) for x in range(3)]

        elif text == 'тяга'or text == 'тяга 1' or text == 'deadlift 1':
            assert header[i+1] == '2'
            assert header[i+2] == '3'
            assert header[i+3].lower().replace('.','') in ['рек','rec']
            fieldnames.append('Deadlift1Kg')
            fieldnames.append('Deadlift2Kg')
            fieldnames.append('Deadlift3Kg')
            fieldnames.append('Deadlift4Kg')
            [next(iterable) for x in range(3)]

        elif text == 'сумма' or text =='total' or text=='result' or text =='сумма баллов':
            fieldnames.append('TotalKg')
        elif text == 'результат':
            fieldnames.append('TotalKg')

        elif text == 'очки' or text == 'points': # This is the Wilks. But we prefer to re-calculate it ourselves.
            fieldnames.append('IGNORE')

        elif text == 'тренер':
            fieldnames.append('IGNORE')

        elif text == 'страна/клуб':
            fieldnames.append('IGNORE')
        elif text == 'страна':
            fieldnames.append('Country')

        elif text == '':
            fieldnames.append('IGNORE')
        elif any (x in text for x in ['жим мн. повт. вес','многоповторный','повторы']): #Bench reps
            fieldnames.append('IGNORE')
        else:
            die('Fix parse_fieldnames(): Unknown column header text: "%s"' % text)

    return fieldnames


# Given a list of lines all of which belong to the same sheet, parse that
# into an OpenPowerlifting-style CSV.
def parse_sheet(sheet):
    assert 'Sheet' in sheet[0][0]
    assert sheet[0][0].count(':') == 1

    csv = oplcsv.Csv()

    # Ignore some sheets that don't contain any powerlifting.
    if 'судейская кол' in sheet[0][0].lower():
        return csv
    elif 'нж ' in sheet[0][0].lower() or 'народный жим' in sheet[0][0].lower():
        # This is the "People's Bench", which I think is bench-for-reps.
        return csv
    elif 'пауэрспорт' in sheet[0][0].lower() or 'powersport' in sheet[0][0].lower():
        return csv #"Power sport", overhead-press + bicep-curl
    elif 'roll' in sheet[0][0].lower():
        return csv
    elif 'командный зачет' in sheet[0][0].lower():
        return csv #Team results
    elif 'командное первенство' in sheet[0][0].lower():
        return csv
    elif 'apollon' in sheet[0][0].lower():
        return csv
    elif 'hub' in sheet[0][0].lower():
        return csv
    elif 'grip' in sheet[0][0].lower():
        return csv    
    elif 'excalibur' in sheet[0][0].lower():
        return csv    
    elif 'silver bullet' in sheet[0][0].lower():
        return csv 
    elif 'много' in sheet[0][0].lower() or 'любители двоеборье' in sheet[0][0].lower(): #Bench reps
        return csv
    elif 'богатырский' in sheet[0][0].lower(): #Heroic Press ?? Some kind of overhead press maybe
        return csv
    elif 'корпус' in sheet[0][0].lower(): #Results
        return csv
    elif 'судейский бригада' in sheet[0][0].lower():
        return csv
    elif 'арм' in sheet[0][0].lower(): #Arm wrestling
        return csv
    elif 'records' in sheet[0][0].lower() or 'рекорды' in sheet[0][0].lower():
        return csv
    # Figure out event, equipment, etc., and store in obj.
    obj = parse_sheetname(sheet[0][0].split(':')[1])

    #RPU often splits headers across multiple lines,fix this
    sheet = fix_headers(sheet)


    # Look through the sheet for column information and mark up the CSV.
    # All columns are given a name -- the extra ones are removed later.
    csv.fieldnames = parse_fieldnames(sheet)

    # The WeightClassKg information is stateful, between rows.
    assert not 'WeightClassKg' in csv.fieldnames
    csv.fieldnames.append('WeightClassKg')
    assert not 'Event' in csv.fieldnames
    csv.fieldnames.append('Event')
    assert not 'Equipment' in csv.fieldnames
    csv.fieldnames.append('Equipment')
    csv.fieldnames.append('Amateur')
    csv.fieldnames.append('Tested')
    csv.fieldnames.append('Federation')

    weightclass = None

    # Iterate over each line, skipping the two header lines.
    for line in sheet[get_header_linenum(sheet)+2:]:
        text = ''.join(line)

        # Stop iteration once the 'Best Lifters' section is reached.
        if 'Абсолютный' in text or 'List absolute winners' in text:
            break

        # Skip empty lines.
        if text == '':
            continue

        # Detect lines that set WeightClassKg state.
        if 'ВЕСОВАЯ КАТЕГОРИЯ' in text or 'Body Weight Category' in text:
            weightclass = re.findall(r"[-+]?\d*\.\d+|\d+",text)[0]
            continue

        # If we've made it this far, the line should be for a lifter!
        # Make sure they have a name!
        if 'InternationalName' in csv.fieldnames and not line[csv.index('InternationalName')]:
            continue
        if 'Name' in csv.fieldnames and not line[csv.index('Name')]:
            continue


            line[totalidx] = str(max(weight(line[idx1]), weight(line[idx2]), weight(line[idx3])))


        line.append(weightclass)
        line.append(obj['event'])
        line.append(obj['equipment'])
        line.append(obj['amateur'])
        line.append(obj['tested'])
        line.append(obj['federation'])
        assert len(line) == len(csv.fieldnames)
        csv.rows.append(line)

    # Remove all the columns named 'IGNORE' before returning the CSV for integration.
    while 'IGNORE' in csv.fieldnames:
        csv.remove_column_by_name('IGNORE')

    unreverse_names(csv)

    return csv


# Handles the Division-Age column, which looks like below:
#   Открытая 20-23 (21.11.1986)/30
# Converts to English and separates into Division and Age columns.
def standardize_division_age(csv):
    assert 'Division-Age' in csv.fieldnames
    assert 'Tested' in csv.fieldnames
    assert 'Amateur' in csv.fieldnames
    assert not 'Division' in csv.fieldnames
    assert not 'Age' in csv.fieldnames

    csv.append_columns(['Division','Age'])

    idx = csv.index('Division-Age')
    dividx = csv.index('Division')
    ageidx = csv.index('Age')
    amateuridx = csv.index('Amateur')
    testedidx = csv.index('Tested')
    
    for row in csv.rows:
        # Fill in the Age.
        if '/' in row[idx]:
            row[ageidx] = row[idx].split('/')[1].strip()
            row[idx]=row[idx].replace(' - ','-')

        # Fill in the Division.
        # Handle the divisions with numbers first.
        if 'Открытая 20-23' in row[idx]:
            division = 'Open 20-23'
        elif 'Открытая 24-39' in row[idx]:
            division = 'Open 24-39'
        elif 'Юниорки 20-23' in row[idx] or 'Juniors 20-23' in row[idx] or 'Юниор 20-23' in row[idx]:
            division = 'Juniors 20-23'
        elif 'Юноши 13-15' in row[idx] or 'Teen 13-15' in row[idx]:
            division = 'Teen 13-15'
        elif 'Teen 13-19' in row[idx] or 'Юноши 13-19' in row[idx]:
            division = 'Teen 13-19'
        elif 'Юноши 15-19' in row[idx]or 'Teenage 15-19' in row[idx] or 'Teens 15-19' in row[idx]:
            division = 'Teen 15-19'
        elif 'Юноши 14-16' in row[idx]:
            division = 'Teen 14-16'
        elif 'Юноши 14-18' in row[idx]:
            division = 'Teen 14-18'
        elif 'Юноши 16-17' in row[idx] or 'Teen 16-17' in row[idx]:
            division = 'Teen 16-17'
        elif 'Юноши 18-19' in row[idx] or 'Teen 18-19' in row[idx]:
            division = 'Teen 18-19'
        elif 'Юноши 17-19' in row[idx] or 'Teen 17-19' in row[idx]:
            division = 'Teen 17-19'
        elif 'Teen' in row[idx] or 'Юноши' in row[idx]:
            division ='Teen'
        elif 'Sub Masters 33-39' in row[idx]:
            division = 'Sub Masters 33-39'
        elif 'Masters 40+' in row[idx]:
            division = 'Masters 40+'
        elif 'Мастера 40-44' in row[idx] or 'Masters 40-44' in row[idx]:
            division = 'Masters 40-44'
        elif 'Master 40-49' in row[idx] or 'Masters 40-49' in row[idx] or 'Мастера 40-49' in row[idx]:
            division = 'Masters 40-49'
        elif 'Мастера 45-49' in row[idx] or 'Masters 45-49' in row[idx]:
            division = 'Masters 45-49'
        elif 'Мастера 50-54' in row[idx] or 'Masters 50-54' in row[idx]:
            division = 'Masters 50-54'
        elif 'Master 50-59' in row[idx] or 'Masters 50-59' in row[idx] or 'Мастера 50-59' in row[idx]:
            division = 'Masters 50-59'
        elif 'Мастера 55-59' in row[idx] or 'Masters 55-59' in row[idx]:
            division = 'Masters 55-59'
        elif 'Мастера 60-64' in row[idx] or 'Masters 60-64' in row[idx]:
            division = 'Masters 60-64'
        elif 'Master 60-69' in row[idx] or 'Мастера 60-69' in row[idx]:
            division = 'Masters 60-69'
        elif 'Мастера 65-69' in row[idx]:
            division = 'Masters 65-69'
        elif 'Мастера 70-79' in row[idx] or 'Master 70-79' in row[idx]:
            division = 'Masters 70-79'
        elif 'Мастера (' in row[idx]:
            division = 'Masters'
        elif 'Мастера 2' in row[idx]:
            division = 'Masters 2'
        elif 'Мастера 3' in row[idx]:
            division = 'Masters 3'

        elif 'Открытая' in row[idx] or 'Open' in row[idx]:
            division = 'Open'
        elif any( div in row[idx] for div in ['Юниоры','Junior','Юниорки']):
            division = 'Juniors'
        elif 'Девушки' in row[idx]:
            division = 'Girls'

        elif 'OPEN' in row[idx]:
            division = 'Open'

        else:
            die('Fix standardize_division_age(): Unknown division "%s"' % row[idx])

        division = row[testedidx] + ' ' + row[amateuridx] + ' ' + division
        row[dividx] = division.replace('  ',' ').strip()

    # Remove the now-extraneous columns.
    csv.remove_column_by_name('Division-Age')
    csv.remove_column_by_name('Amateur')
    csv.remove_column_by_name('Tested')


def mark_dqs(csv):
    place_idx = csv.index('Place')
    total_idx = csv.index('TotalKg')
    for row in csv.rows:
        if row[place_idx] == 'DQ' and row[total_idx] !='':
            row[place_idx] ='DD'
            row[total_idx]=''
        elif not row[place_idx] or row[place_idx] == '-':
            row[place_idx] = 'DQ'
        elif row[total_idx].replace('.','').replace('-','').isdigit() and float(row[total_idx])==0.0:
            row[place_idx] = 'DQ'
            row[total_idx]=''

def remove_zeros(csv):
    for row in csv.rows:
        for ii in range(len(row)):
            if row[ii].replace('.','').replace('-','').isdigit() and float(row[ii])==0.0:
                row[ii] = ''

def unreverse_names(csv):

    if 'InternationalName' in csv.fieldnames:
        nameidx = csv.index('InternationalName')
    elif 'Name' in csv.fieldnames:
        nameidx= csv.index('Name')
    for row in csv.rows:
        parts = row[nameidx].split()
        parts = [name.title() for name in parts]

        # The last name is probably the given first name.
        fixed = [parts[-1]] + parts[:-1]
        name = ' '.join(fixed)

        row[nameidx] = name

#Names sometimes have something in brackets after them - extra divisions maybe?
def cleanup_names(csv):
    if 'InternationalName' in csv.fieldnames:
        nameidx = csv.index('InternationalName')
    elif 'Name' in csv.fieldnames:
        nameidx= csv.index('Name')

    for row in csv.rows:
        row[nameidx]= re.sub('\(.*\)','',row[nameidx])
        row[nameidx]=row[nameidx].strip()

def main(filename):
    # Since the input is comma-separated, store the file as a list of lists.
    with open(filename) as fd:
        lines = [x.strip().split(',') for x in fd.readlines()]

    # Split the input filename into sheets, each of which is an independent CSV.
    sheetlist = split_by_sheet(lines)

    # Parse each sheet independently, then join them all together into a single CSV.
    csv = oplcsv.Csv()
    for sheet in sheetlist:
        sheetcsv = parse_sheet(sheet)
        csv.cat(sheetcsv)

    # Now it's time to standardize the CSV a little bit!
    # We have some temporary columns hanging out.
    standardize_division_age(csv)
    mark_dqs(csv)
    split_country(csv)
    remove_zeros(csv)
    cleanup_names(csv)

    # At the moment, this is not useful information.
    csv.remove_column_by_name('Federation')

    csv.write(sys.stdout)
    return 0


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print(" Usage: %s results.csv > entries.csv" % sys.argv[0])
        sys.exit(1)
    sys.exit(main(sys.argv[1]))
