#!/usr/bin/env python3
# vim: set ts=8 sts=4 et sw=4 tw=99:
#
# Standardize the results.csv to the OpenPowerlifting
# internal format.
#

import sys
from os.path import join,realpath,dirname
sys.path.append(join(dirname(dirname(dirname(realpath(__file__)))),"scripts"))

from oplcsv import Csv
import re


#!/usr/bin/env python3
# Given a results.csv as outputted by wrpf-parse, parse each sheet one at a time
# and join all the sheets together into an OpenPowerlifting-formatted CSV file.

import oplcsv
import sys


def die(s):
    print(s, file=sys.stderr)
    sys.exit(1)


# Given the array of lines, split it up into an array per-sheet.
def split_by_sheet(lines):
    for i in range(len(lines)):
        if 'Sheet' in lines[i][0]:
            break
    assert i < len(lines)
    assert 'Sheet' in lines[i][0]

    sheetlist = []
    sheet = None

    for line in lines[i:]:
        # If this line starts a new sheet, generate a new array.
        if 'Sheet' in line[0]:
            sheet = []
            sheetlist.append(sheet)
            sheet.append(line)
        elif 'bench press' in ''.join(line[0]).lower():
            sheet = []
            sheetlist.append(sheet)
            sheet.append(['Sheet : ' +''.join(line[0])])
        else:
            sheet.append(line)
        

    return sheetlist


# Given the name of a sheet, return a dictionary describing the sheet.
def parse_sheetname(s):
    obj = {}

    federation = ''
    event = None
    amateur = 'Pro' # By default, unless otherwise specified.
    tested = '' # By default, unless otherwise specified.
    equipment = 'Wraps' # By default, unless otherwise specified.

    # Parse word-by-word to make sure that every word is understood. 
    for word in s.lower().split():

        # Events
        if word == 'пл' or word == 'пауэрлифтинг' or word == 'pl':
            assert not event
            event = 'SBD'
        elif word == 'жим' or word =='им' or word=='bench':
            assert not event
            event = 'B'
            if equipment == 'Wraps':
                equipment = 'Raw'
        elif word == 'тяга':
            assert not event
            event = 'D'
            if equipment == 'Wraps':
                equipment = 'Raw'
        elif word == 'двоеборье':
            assert not event
            event = 'BD'
            if equipment == 'Wraps':
                equipment = 'Raw'

        # Equipment
        elif word == 'однослой':
            equipment = 'Single-ply'
        elif word == 'экипировке':
            equipment = 'Multi-ply'

        # Booleans.
        elif word == 'люб.' or word == 'любители':
            amateur = 'Amateur'
        elif word == 'pro':
            assert amateur == 'Pro'
        elif word == 'дк' or word == 'д_к':
            tested = 'Tested'

        # Grammatical ignorables.
        elif word == 'в':
            pass
        elif word == 'лежа':
            pass
        
        elif word == 'протокол': #Results
            pass


        # Other ignorables.
        elif word == 'сфо': # Not sure.
            pass
        elif word == 'становая': # First word in 'deadlift'.
            pass
        elif word == 'raw':
            pass
        elif word == 'штанги': #Barbell
            pass
        elif word == 'лежачи': #Lying (as in bench)
            pass
        elif word == 'single':
            pass
        elif word == 'press':
            pass
        elif word == 'only':
            pass
        else:
            die('Fix parse_sheetname(): Unknown word "%s" in "%s"' % (word, s))

    obj['federation'] = federation
    obj['event'] = event
    obj['amateur'] = amateur
    obj['tested'] = tested
    obj['equipment'] = equipment

    return obj


# Find the line that contains column information (the line below does also).
def get_header_linenum(sheet):
    for i in range(len(sheet)):
        if len(sheet[i]) >1 and sheet[i][1] in ['П.І.','Имя','NAME']:
            return i
    die("get_header_linenum() failed to find the header.")


def parse_fieldnames(sheet):
    fieldnames = []

    headernum = get_header_linenum(sheet)
    header = sheet[headernum]
    header_next = sheet[headernum+1]

    # Name all the columns.
    iterable = iter(range(len(header)))

    #First column is place, has no label
    next(iterable)
    fieldnames.append('Place')
    for i in iterable:
        text = header[i]

        if text == 'Место':
            fieldnames.append('Place')
        elif text =='П.І.' or text =='Имя':
            fieldnames.append('InternationalName')
        elif text =='NAME':
            fieldnames.append('InternationalName')
        elif text == 'МІСЦЕ': #City
            fieldnames.append('IGNORE')
        elif text =='Город' or text =='City / TEAM': #Home city/gym
            fieldnames.append('IGNORE')
        elif text == 'Дата народ.'or text =='День рождения' or text =='DB': #Birthdate
            fieldnames.append('BirthDate')
        elif text == 'власна вага' or text =='Вес' or text =='PW': #Bodyweight
            fieldnames.append('BodyweightKg')
        elif text == 'Сума по коеф.' or text=='Абсолют' or text =='Coef': #Wilks
            fieldnames.append('IGNORE')
        elif text == 'Виконаний норматив': #Some kind of points?
            fieldnames.append('IGNORE')
        elif text == 'Страна' or text =='Country': #Country
            fieldnames.append('Country')
        elif text =='Звание' or text =='Rank': #Rank
            fieldnames.append('IGNORE')
        elif text == 'Тренера'or text =='Coach': #Coach
            fieldnames.append('IGNORE')

        elif text == 'Сумма'or text =='Total':
            fieldnames.append('TotalKg')

        elif text == 'Присед 1' or text =='SQ 1':
            assert header[i+1] in ['Присед 2','SQ 2']
            assert header[i+2] in ['Присед 3','SQ 3']
            fieldnames.append('Squat1Kg')
            fieldnames.append('Squat2Kg')
            fieldnames.append('Squat3Kg')
            if header[i+3] == 'Сумма':
                fieldnames.append('BestSquatKg')
                [next(iterable) for x in range(3)]
            elif header[i+3] in ['Присед 4','SQ 4']:
                fieldnames.append('Squat4Kg')
                [next(iterable) for x in range(3)]

        elif text == 'Жим 1' or text =='BP 1':
            assert header[i+1] in ['Жим 2','BP 2']
            assert header[i+2] in ['Жим 3','BP 3']
            fieldnames.append('Bench1Kg')
            fieldnames.append('Bench2Kg')
            fieldnames.append('Bench3Kg')
            if header[i+3] == 'Сумма':
                fieldnames.append('BestBenchKg')
                [next(iterable) for x in range(3)]
            elif header[i+3] in ['Жим 4','BP 4']:
                fieldnames.append('Bench4Kg')
                [next(iterable) for x in range(3)]

        elif text == 'Тяга 1' or text =='DL 1':
            assert header[i+1] in ['Тяга 2','DL 2']
            assert header[i+2] in ['Тяга 3','DL 3']
            fieldnames.append('Deadlift1Kg')
            fieldnames.append('Deadlift2Kg')
            fieldnames.append('Deadlift3Kg')
            if header[i+3] == 'Сумма':
                fieldnames.append('BestDeadliftKg')
                [next(iterable) for x in range(3)]
            elif header[i+3] in ['Тяга 4','DL 4']:
                fieldnames.append('Deadlift4Kg')
                [next(iterable) for x in range(3)]

        elif text == '':
            fieldnames.append('IGNORE')

        else:
            die('Fix parse_fieldnames(): Unknown column header text: "%s"' % text)

    return fieldnames


# Given a list of lines all of which belong to the same sheet, parse that
# into an OpenPowerlifting-style CSV.
def parse_sheet(sheet):
    assert 'Sheet' in sheet[0][0]
    assert sheet[0][0].count(':') == 1

    csv = oplcsv.Csv()

    title=sheet[0][0].lower()
    # Ignore some sheets that don't contain any powerlifting.
    if 'судейская кол' in title:
        return csv
    elif 'нж ' in title:
        # This is the "People's Bench", which I think is bench-for-reps.
        return csv
    elif 'багатоповторний'  in title or 'multy' in title: #Multiple- probably bench for reps
        return csv



    # Figure out event, equipment, etc., and store in obj.
    obj = parse_sheetname(sheet[0][0].split(':')[1])

    # Look through the sheet for column information and mark up the CSV.
    # All columns are given a name -- the extra ones are removed later.
    csv.fieldnames = parse_fieldnames(sheet)

    # The WeightClassKg information is stateful, between rows.
    assert not 'WeightClassKg' in csv.fieldnames
    csv.fieldnames.append('WeightClassKg')
    assert not 'Division' in csv.fieldnames
    csv.fieldnames.append('Division')
    assert not 'Sex' in csv.fieldnames
    csv.fieldnames.append('Sex')
    assert not 'Event' in csv.fieldnames
    csv.fieldnames.append('Event')
    assert not 'Equipment' in csv.fieldnames
    csv.fieldnames.append('Equipment')
    csv.fieldnames.append('Amateur')
    csv.fieldnames.append('Tested')
    csv.fieldnames.append('Federation')

    weightclass = None
    division = None
    sex = None
    equipment = None
    amateur = None


    #There's often a bunch of nonsense at the bottom
    end_line = len(sheet[get_header_linenum(sheet)+2:])
    for ii in range(len(sheet[get_header_linenum(sheet)+2:]),0,-1):
        if len([c for c in sheet[ii] if c !='']) > 3:
            break
        else:
            end_line = ii

    #Then the name of the sheet told us nothing, see if there is information above the header
    if obj['event'] == None:
        above_header =(''.join(sheet[get_header_linenum(sheet)-1])).lower()
        if 'bench' in above_header:
            obj['event']='B'
        elif 'power' in  above_header:
            obj['event']='SBD'




    # Iterate over each line, skipping the two header lines.
    for line in sheet[get_header_linenum(sheet)+1:end_line]:
        text = ''.join(line).lower()

        # Skip empty lines.
        if text == '':
            continue

        # Detect lines that set WeightClassKg state.
        if ' кг' in text:
            weightclass = re.findall(r"\d*\.\d+|(\d+|\+)",text)[0]
            continue

        if 'multy rep' in text:
            break


        # Sex and division are given between lifter rows
        if 'жен. (' in text or 'woman (' in text:
            sex = 'F'
            division = re.findall(r"\((.*?)\)",text)[0]
            continue
        elif 'муж. (' in text or 'men (' in text:
            sex = 'M'
            division = re.findall(r"\((.*?)\)",text)[0]
            continue


        #Equipment and amateur/pro are given between rows
        if 'raw' in text:
            if 'S' in obj['event']:
                obj['equipment'] = 'Wraps'
            else:
                obj['equipment']='Raw'
            obj['amateur'] = text.split()[-1].title()
            continue
        elif 'eq' in text:
            obj['equipment'] = 'Multi-ply' #Check this
            obj['amateur'] = text.split()[-1].title()
            continue 

        # If we've made it this far, the line should be for a lifter!
        # Make sure they have a name!
        if not line[csv.index('InternationalName')]:
            continue
        line.append(weightclass)
        line.append(division)
        line.append(sex)
        line.append(obj['event'])
        line.append(obj['equipment'])
        line.append(obj['amateur'])
        line.append(obj['tested'])
        line.append(obj['federation'])

        assert len(line) == len(csv.fieldnames)
        csv.rows.append(line)

    # Remove all the columns named 'IGNORE' before returning the CSV for integration.
    while 'IGNORE' in csv.fieldnames:
        csv.remove_column_by_name('IGNORE')



    unreverse_names(csv)

        
    return csv


# Handles the Division and Age columns, which looks like below:
#   Открытая 20-23 (21.11.1986)/30
# Converts to English and separates into Division and Age columns.
def standardize_division_age(csv):
    assert 'Tested' in csv.fieldnames
    assert 'Amateur' in csv.fieldnames
    assert 'Division' in csv.fieldnames
    assert 'BirthDate' in csv.fieldnames

    csv.append_columns(['BirthYear'])
    
    dividx = csv.index('Division')
    bdidx = csv.index('BirthDate')
    byidx = csv.index('BirthYear')
    amateuridx = csv.index('Amateur')
    testedidx = csv.index('Tested')

    for row in csv.rows:
        # Fill in the Age.
        if '.' in row[bdidx]:
            row[byidx] = row[bdidx].split('.')[-1].strip()

        # Fill in the Division.
        # Handle the divisions with numbers first.
        if 'children 8' in row[dividx]:
            division = 'Youth 8'
        elif 'children 9' in row[dividx]:
            division = 'Youth 9'
        elif 'children 11-12' in row[dividx]:
            division = 'Youth 11-12'
        elif 'teenagers 13-15' in row[dividx]:
            division = 'Teen 13-15'
        elif 'teenagers 16-17' in row[dividx]:
            division = 'Teen 16-17'
        elif 'teenagers 18-19' in row[dividx]:
            division = 'Teen 18-19'
        elif 'juniors 20-23' in row[dividx]:
            division = 'Juniors 20-23'
        elif 'submasters 33-39' in row[dividx]:
            division = 'Submasters 33-39'
        elif 'masters 40-44' in row[dividx]:
            division = 'Masters 40-44'
        elif 'masters 45-49' in row[dividx]:
            division = 'Masters 45-49'
        elif 'masters 50-54' in row[dividx]:
            division = 'Masters 50-54'
        elif 'masters 55-59' in row[dividx]:
            division = 'Masters 55-59'
        elif 'masters 60-64' in row[dividx]:
            division = 'Masters 60-64'
        elif 'masters 65-69' in row[dividx]:
            division = 'Masters 65-69'
        elif 'masters 70-74' in row[dividx]:
            division = 'Masters 70-74'
        elif 'masters 75-79' in row[dividx]:
            division = 'Masters 75-79'

        elif 'paralympians' in row[dividx]:
            division = 'Paralympian'
        elif 'open' in row[dividx]:
            division = 'Open'
        elif 'mpf' in row[dividx]:
            division = 'Military/Fire/Police'
        else:
            die('Fix standardize_division_age(): Unknown division "%s"' % row[dividx])

        division = row[testedidx] + ' ' + row[amateuridx] + ' ' + division
        row[dividx] = division.replace('  ',' ').strip()

    # Remove the now-extraneous columns.
    csv.remove_column_by_name('BirthDate')
    csv.remove_column_by_name('Amateur')
    csv.remove_column_by_name('Tested')


#Mark DQs properly and make sure that place is an integer.
def cleanup_place(csv):
    place_idx = csv.index('Place')
    total_idx = csv.index('TotalKg')
    for row in csv.rows:
        if '.00' in row[place_idx]: #Convert place to an integer if it wasn't already
            row[place_idx]=str(int(float(row[place_idx])))

        #Somewhat convoluted way of checking if a lifter is marked DQ and has a nonzero total
        if row[place_idx] == 'DQ' and row[total_idx].replace('.','').replace('-','').isdigit() and float(row[total_idx])!=0.0:
            row[place_idx] ='DD'
            row[total_idx]=''
        elif row[place_idx] == '' and row[total_idx].replace('.','').replace('-','').isdigit() and float(row[total_idx])!=0.0:
            row[place_idx] ='DD'
            row[total_idx]=''
        elif row[place_idx] == 'DT':
            row[place_idx]='DD'
            row[total_idx]=''
        #Everything else is a regular DQ
        elif not row[place_idx] or row[place_idx] == '-' or row[place_idx] =='DOC':
            row[place_idx] = 'DQ'
            row[total_idx]=''
        elif row[total_idx].replace('.','').replace('-','').isdigit() and float(row[total_idx])==0.0:
            row[place_idx] = 'DQ'
            row[total_idx]=''
        elif row[total_idx] == '':
            row[place_idx] = 'DQ'

def cleanup_lift(csv, fieldname):
    if fieldname in csv.fieldnames:
        idx = csv.index(fieldname)

        for row in csv.rows:
            amount = row[idx]

            amount = ''.join(c for c in amount if c.isdigit() or c in ['.','-'])
            amount = amount.replace('.00','').replace('.0','')


            if amount == 'X' or amount.replace('-','') == '0' or not any(c.isdigit() for c in amount):
                amount = ''

            #Sometimes numbers have more than 2 commas, if so remove the second one
            if len([ii for ii, a in enumerate(amount) if a == '.']) >1:
                amount = amount[:amount.rfind('.')]+amount[amount.rfind('.')+1:]

            row[idx] = amount

def assign_best(csv, liftname):
    idx1 = csv.index('%s1Kg' % liftname)
    idx2 = csv.index('%s2Kg' % liftname)
    idx3 = csv.index('%s3Kg' % liftname)
    bestidx = csv.index('Best%sKg' % liftname)

    def weight(str):
        try:
            return float(str)
        except ValueError:
            return 0.0

    for row in csv.rows:
        best = max(weight(row[idx1]), weight(row[idx2]), weight(row[idx3]))

        if float(best) > 0:
            row[bestidx] = str(best)

def assign_total(csv):

    if 'TotalKg' not in csv.fieldnames:
        csv.append_column('TotalKg')
    idx = csv.index('TotalKg')

    def weight(str):
        try:
            return float(str)
        except ValueError:
            return 0.0

    for row in csv.rows:
        if row[idx] == '':
            total = 0.0
            if 'BestSquatKg' in csv.fieldnames:
                total += weight(row[csv.index('BestSquatKg')])
            if 'BestBenchKg' in csv.fieldnames:
                total += weight(row[csv.index('BestBenchKg')])
            if 'BestDeadliftKg' in csv.fieldnames:
                total += weight(row[csv.index('BestDeadliftKg')])

            if total != 0.0:
                row[idx] = str(total)       




def unreverse_names(csv):

    if 'InternationalName' in csv.fieldnames:
        nameidx = csv.index('InternationalName')
    elif 'Name' in csv.fieldnames:
        nameidx= csv.index('Name')
    for row in csv.rows:
        parts = row[nameidx].split()
        parts = [name.title() for name in parts]

        # The last name is probably the given first name.
        fixed = [parts[-1]] + parts[:-1]
        name = ' '.join(fixed)

        row[nameidx] = name

def main(filename):
    # Since the input is comma-separated, store the file as a list of lists.
    with open(filename) as fd:
        lines = [x.strip().split(',') for x in fd.readlines()]

    # Split the input filename into sheets, each of which is an independent CSV.
    sheetlist = split_by_sheet(lines)

    # Parse each sheet independently, then join them all together into a single CSV.
    csv = oplcsv.Csv()
    for sheet in sheetlist:
        sheetcsv = parse_sheet(sheet)
        csv.cat(sheetcsv)


    for x in ['Squat1Kg', 'Squat2Kg', 'Squat3Kg','Squat4Kg', 'Bench1Kg', 'Bench2Kg', 'Bench3Kg','Bench4Kg',
            'Deadlift1Kg', 'Deadlift2Kg', 'Deadlift3Kg','Deadlift4Kg', 'TotalKg','BodyweightKg']:
        cleanup_lift(csv, x)

    if 'BestSquatKg' not in csv.fieldnames:
        csv.append_column('BestSquatKg')
        assign_best(csv, 'Squat')
    if 'BestBenchKg' not in csv.fieldnames:
        csv.append_column('BestBenchKg')
        assign_best(csv, 'Bench')
    if 'BestDeadliftKg' not in csv.fieldnames:
        csv.append_column('BestDeadliftKg')
        assign_best(csv, 'Deadlift')

    assign_total(csv)

    # Now it's time to standardize the CSV a little bit!
    # We have some temporary columns hanging out.
    standardize_division_age(csv)
    cleanup_place(csv)

    # At the moment, this is not useful information.
    csv.remove_column_by_name('Federation')

    csv.write(sys.stdout)
    return 0


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print(" Usage: %s results.csv" % sys.argv[0], file=sys.stderr)
        sys.exit(1)
    main(sys.argv[1])
